[mode]
# 指定最大的并行任务数量
threads = 3
# 指定当某个任务失败后，尝试重新运行的最大次数
retry = 1
# 指定是否对任务的资源消耗进行监控
monitor_resource = True
# 指定监控资源的时间间隔，单位为秒
monitor_time_step = 2
# 指定任务运行前，是否检测资源充足
check_resource_before_run = True
# input options
fq = /rdc22/hanwumei/80043/20200528/Bcl2fastq_mismatch1/EPS19F1X1QL4_S5_R1_001.fastq.gz
fq2 = /rdc22/hanwumei/80043/20200528/Bcl2fastq_mismatch1/EPS19F1X1QL4_S5_R2_001.fastq.gz
sample = EPS19F1X1QL4_S5
adapters = /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/QIA_AdapterPrimer/adapters.fasta
primers = /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/QIA_AdapterPrimer/primer_for_cutadapt.fasta
roi = /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/QIA_TargetRegion/QIAseq_DNA_panel.CDHS-33088Z-140.rangeOfInterest.bed
;roi = /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/QIA_TargetRegion/numbered.QIAseq_DNA_panel.CDHS-33088Z-140.rangeOfInterest.bed
genome = /nfs2/database/1_human_reference/hg19/ucsc.hg19.fasta
;genome = /nfs2/database/1_human_reference/hs37d5/hs37d5.fa
mutations = /data/users/dqgu/workplace/smallDrugPanel/target.genes.target_mutation.vcf
# software
bwa = /nfs2/software/bwa-0.7.17/bwa
;bwa = /data/users/dqgu/workplace/smallDrugPanel/bwa-mem2-2.0_x64-linux/bwa-mem2.avx2


[removeUMI]
# 考虑到UMI校正的存在以及后续还会使用genecore，去除--correction参数的功能
# 经测试发现，fastp能够智能的识别read1中包含的固定序列并切除掉，同时也能把read2中的固定序列和接头序列一并识别并切除，震惊！
# 由于固定序列实际只有11bp，起初我这里设置参数12，即额外跳过一个碱基，注意：fastp会把read1中的11bp固定序列切除，并且还会切除固定序列前面的一个碱基。
# fastp似乎能根据umi_len信息去除read1末尾的固定序列，即如果指定切除12个，则也会切除read1末尾的11+1个碱基(当read1末尾能和11个碱基的固定序列匹配)
# 固定序列的后1/2个碱基测序质量较差，需要去除
# 如果发生测通，read1末尾可能以固定序列和UMI序列甚至接头序列结尾，read1测到得固定序列质量非常好，索引可以用固定序列作为街头信息
# 考虑到read2也可能测到adapter, 虽然fastp可以自动识别，但是我还是把固定序列2作为接头，保险起见。
# 由于read1末尾得一个碱基质量很差，需删除read1末尾一个碱基（trim_tail1去除），
# 与此同时，也应该把read2前1个碱基也去掉（通过trim_front2去除），这样才能保证后续利用fastp根据overlap正确地去除read2末尾的primer序列
# 分析发现，read2末尾2个碱基得组成比例似乎存在问题，这里通过trim_tail2把read2末尾得2个碱基去掉。
# fastp会先进行UMI提取，然后进行global trimming
read1_adapter = AGGACTCCAAT
read2_adapter = CAAAACGCAATACTGTACATT
cmd = /nfs2/software/fastp/fastp -Q --trim_front1 0  --trim_tail1 2 --trim_front2 2 --trim_tail2 2 --adapter_sequence ${read1_adapter} --adapter_sequence_r2 ${read2_adapter} --umi --umi_loc read2 --umi_len 12 --umi_skip 11 --n_base_limit 8 --length_required 40 -i ${mode:fq} -I ${mode:fq2} -o ${mode:sample}.rmUMI.R1.fq  -O ${mode:sample}.rmUMI.R2.fq -h ${mode:sample}.raw.html -j ${mode:sample}.raw.json

[removePrimerInRead1]
# 通过cutadpat软件把read1中开头得primer去除
# 这里q设置为0，是为以防对read1尾部或read2第一个碱基进行了剪切，影响后续对Read2中出现的primer的去除
# primer信息会提取到read name的开头部分
cmd = cutadapt -j 10 -g file:${mode:primers} -x '{name}:' --discard-untrimmed -m 30 -q 0 -e 0.15 --overlap 10 --info-file ${mode:sample}.cutPrimer.detail.txt -o ${mode:sample}.rmUMI.rmPrimer1.R1.fq -p ${mode:sample}.rmUMI.rmPrimer1.R2.fq ${mode:sample}.rmUMI.R1.fq ${mode:sample}.rmUMI.R2.fq > ${mode:sample}.cutPrimer.log
depend = removeUMI

[syncFastqName]
# 把read2得name和read1得name同步
cmd = python ~/PycharmProjects/nestcmd/SmallDrugPanel/sync_readname.py ${mode:sample}.rmUMI.rmPrimer1.R1.fq ${mode:sample}.rmUMI.rmPrimer1.R2.fq
depend = removePrimerInRead1

[removePrimerInRead2]
# fastp会根据overlap自动识别出read2中的primer,并且将primer去除干净，如果read2中包含primer，这意味着read1和read2包含的信息应该一致
# 理论上这个primer的去除不会影响比对，似乎可以省略，但或许对UMI collapse产生影响
# 由于fastp会先进行quality trim，然后进行adapter trim
# quality trim 可能导致read1末尾和read2的碱基被切除，这使得fastp根据overlap进行primer切除时出现偏差，因此使用-G，-Q参数
cmd = /nfs2/software/fastp/fastp -Q -G -i ${mode:sample}.rmUMI.rmPrimer1.R1.fq -I ${mode:sample}.rmUMI.rmPrimer1.R2.fq -o ${mode:sample}.rmUMI.Primer12.R1.fq -O ${mode:sample}.rmUMI.Primer12.R2.fq -h ${mode:sample}.rmUMI.Primer12.html -j ${mode:sample}.rmUMI.Primer12.json
depend = syncFastqName

[finalQC]
# 最后再用fastp去除低质量reads
cmd = /nfs2/software/fastp/fastp --disable_adapter_trimming --length_required 25 -i ${mode:sample}.rmUMI.Primer12.R1.fq -I ${mode:sample}.rmUMI.Primer12.R2.fq -h ${mode:sample}.final.html -j ${mode:sample}.final.json -o ${mode:sample}.final.R1.fq -O ${mode:sample}.final.R2.fq
depend = removePrimerInRead2

[umiRawStat]
cmd = python /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/parse_cutadapt_info.py -file ${mode:sample}.cutPrimer.detail.txt -o ${mode:sample} -primer_fasta ${mode:primers}
depend = finalQC

[align]
cmd = ${mode:bwa} mem -M -Y -R "@RG\tID:12878QL1\tSM:12878QL1\tPL:Illumina" -t 5 ${mode:genome} ${mode:sample}.final.R1.fq ${mode:sample}.final.R2.fq -o ${mode:sample}.sam
depend = finalQC

[sortBam]
cmd = samtools sort ${mode:sample}.sam -o ${mode:sample}.sorted.bam
depend = align

[indexBam]
cmd = samtools index ${mode:sample}.sorted.bam
depend = sortBam

;[umiGroup]
;cmd = umi_tools group -I ${mode:sample}.sorted.bam --paired --buffer-whole-contig --group-out=groups.tsv --output-bam -S ${mode:sample}.umiGroup.bam --umi-separator=":"

;[umiDedup]
;cmd = umi_tools dedup --paired -I ${mode:sample}.sorted.bam --output-stats=deduplicated -S ${mode:sample}.umiDedup.bam --umi-separator ':' > dedup.log

[gencore]
cmd = gencore -i ${mode:sample}.sorted.bam -o ${mode:sample}.gencoreDedup.bam -r ${mode:genome} -u '' -b ${mode:roi}
depend = indexBam

[sortConsBam]
# 需要按照read name 排序才有利于fastq的正确转换
cmd = samtools sort -@4 ${mode:sample}.gencoreDedup.bam -o ${mode:sample}.gencoreDedup.sorted.bam
depend = gencore

[indexConsBam]
# 按照read name排序时无法建立索引
cmd = samtools index ${mode:sample}.gencoreDedup.sorted.bam
depend = sortConsBam

[umiStat]
# 会输出ontarget的部分
cmd = python /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/primer_specific_stat.py -bam ${mode:sample}.gencoreDedup.sorted.bam -out_prefix ${mode:sample}.gencore --primer_trimmed
depend = indexConsBam

[sortOnTargetBam]
cmd = samtools sort ${mode:sample}.gencore.onTarget.bam -o ${mode:sample}.gencore.onTarget.sorted.bam
depend = umiStat

[indexOnTargetBam]
cmd = samtools index ${mode:sample}.gencore.onTarget.sorted.bam
depend = sortOnTargetBam

[sortConsBamByName]
cmd = samtools sort -@4 ${mode:sample}.gencoreDedup.bam -o ${mode:sample}.gencoreDedup.nameSorted.bam
depend = gencore

[bam2fastq]
cmd = samtools fastq --threads 3 -1 ${mode:sample}.gencore.R1.fq -2 ${mode:sample}.gencore.R2.fq ${mode:sample}.gencoreDedup.nameSorted.bam
depend = sortConsBamByName

[mutscan]
cmd = mutscan -1 ${mode:sample}.gencore.R1.fq -2 ${mode:sample}.gencore.R2.fq -m ${mode:mutations} -r ${mode:genome} -j ${mode:sample}.mutscan.json -h ${mode:sample}.mutscan.html > ${mode:sample}.mutscan.result.txt
depend = bam2fastq

[vardict]
# --header参数会导致转vcf时失败
cmd = /nfs2/software/vardictJava/VarDict-1.8.0/bin/VarDict -N ${mode:sample} -b ${mode:sample}.gencore.onTarget.sorted.bam -f 0.0001 -G ${mode:genome} -c 1 -S 2 -E 3 -g 4 -th 4 -q 20 -P 3 --fisher ${mode:roi} | /nfs2/software/vardictJava/VarDict-1.8.0/bin/var2vcf_valid.pl -f 0.0001 > ${mode:sample}.vardict.vcf
depend = indexOnTargetBam

