[mode]
# 指定最大的并行任务数量
threads = 3
# 指定当某个任务失败后，尝试重新运行的最大次数
retry = 1
# 指定是否对任务的资源消耗进行监控
monitor_resource = True
# 指定监控资源的时间间隔，单位为秒
monitor_time_step = 2
# 指定任务运行前，是否检测资源充足
check_resource_before_run = True
# input options
fq = /rdc22/hanwumei/80043/20200528/Bcl2fastq_mismatch1/EPS19F1X1QL4_S5_R1_001.fastq.gz
fq2 = /rdc22/hanwumei/80043/20200528/Bcl2fastq_mismatch1/EPS19F1X1QL4_S5_R2_001.fastq.gz
sample = EPS19F1X1QL4_S5
adapters = /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/QIA_AdapterPrimer/adapters.fasta
primers = /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/QIA_AdapterPrimer/primer_for_cutadapt.fasta
roi = /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/QIA_TargetRegion/QIAseq_DNA_panel.CDHS-33088Z-140.rangeOfInterest.bed
;roi = /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/QIA_TargetRegion/numbered.QIAseq_DNA_panel.CDHS-33088Z-140.rangeOfInterest.bed
genome = /nfs2/database/1_human_reference/hg19/ucsc.hg19.fasta
;genome = /nfs2/database/1_human_reference/hs37d5/hs37d5.fa
mutations = /data/users/dqgu/workplace/smallDrugPanel/target.genes.target_mutation.vcf
# software
bwa = /nfs2/software/bwa-0.7.17/bwa
;bwa = /data/users/dqgu/workplace/smallDrugPanel/bwa-mem2-2.0_x64-linux/bwa-mem2.avx2


[removeUMI]
# 考虑到UMI校正的存在以及后续还会使用genecore，去除--correction参数的功能
# fastp会先进行UMI提取，然后进行global trimming(如trim_front和trim_tail)
# 经测试发现，fastp能够智能的识别read1中包含的固定序列并切除掉，同时也能把read2中的固定序列和接头序列一并识别并切除，震惊！
# 由于固定序列实际只有11bp，起初我这里设置参数12，即额外跳过一个碱基，注意：fastp会把read1中的11bp固定序列切除，并且还会切除固定序列前面的一个碱基。
# fastp似乎能根据umi_skip信息去除read1末尾的固定序列，即如果指定跳过read2中UMI后面紧跟的12个碱基，
# 随之，fastp会自动在read1中搜索这12碱基序列，当read1末尾能和这12个碱基的固定序列匹配时，则删除，由于允许一个错配，即使真正的固定序列只有11bp，仍然会删除read1末尾的12个碱基。
# 基于以上原因，-umi_skip只能严格设置为11，要跳过后面测序质量差的碱基，只能通过trim_front2实现
# 固定序列的后1个碱基测序质量较差，需要去除，这个碱基的去除体现在trim_front2参数中。
# 如果发生测通，read1末尾可能以固定序列和UMI序列甚至接头序列结尾，read1测到的固定序列质量非常好，因此可以用固定序列作为接头信息
# 考虑到read2也可能测到adapter, 虽然fastp可以自动识别，但是我还是把固定序列2作为接头，保险起见。
# 分析发现read1末尾的2个碱基质量很差，需删除read1末尾一个碱基（trim_tail1=2去除），与此同时，
# 也应该把read2的前面2个碱基也去掉（通过trim_front2=2去除，这里也顺便去除了固定序列后面比较差的那个碱基），
# 因为只有这样才能保证后续利用fastp根据overlap正确地去除read2末尾的primer序列。当然，当并没有overlap发生时，这也导致浪费掉了1个碱基。
# 另外，分析发现read2末尾2个碱基的组成比例似乎存在问题，这里通过trim_tail2把read2末尾的2个碱基去掉。
# 尽管fastp可以自动识别接头，保险起见，这里还是通过参数直接告诉fastp接头信息。fastp会自己先根据overlap判断接头，然后才会使用用户提供的接头信息
# 下面read1_adapter 为read1中可能包含的11bp固定序列, 测通时包含
# 下面read2_adapter 为read2中可能包含的21bp固定序列, 测通时包含
read1_adapter = AGGACTCCAAT
read2_adapter = CAAAACGCAATACTGTACATT
cmd = /nfs2/software/fastp/fastp -Q --trim_front1 0  --trim_tail1 2 --trim_front2 2 --trim_tail2 2 --adapter_sequence ${read1_adapter} --adapter_sequence_r2 ${read2_adapter} --umi --umi_loc read2 --umi_len 12 --umi_skip 11 --n_base_limit 8 --length_required 40 -i ${mode:fq} -I ${mode:fq2} -o ${mode:sample}.rmUMI.R1.fq  -O ${mode:sample}.rmUMI.R2.fq -h ${mode:sample}.raw.html -j ${mode:sample}.raw.json

[removePrimerInRead1]
# 通过cutadpat软件把read1中开头的primer去除
# 这里q设置为0，是为了防对read1尾部或read2第一个碱基进行了剪切，影响后续对Read2中出现的primer的去除
# 允许错配，因为primer也会测错，甚至还可能出现indel，cutadapt可以较好处理这些情况
# 通过-x参数，primer名称信息会被自动识别并放到read name的开头部分，这样可以方便后续统计每一个primer的捕获详情
# discard-untrimmed  可以保证把不以primer开头的read全部丢弃
# 注意，输入的primer序列必须以'^'开头，这样才能保证cutadapt预期工作，因为一条read可能出现多个primer的序列信息
cmd = cutadapt -j 10 -g file:${mode:primers} -x '{name}:' --discard-untrimmed -m 30 -q 0 -e 0.15 --overlap 10 --info-file ${mode:sample}.cutPrimer.detail.txt -o ${mode:sample}.rmUMI.rmPrimer1.R1.fq -p ${mode:sample}.rmUMI.rmPrimer1.R2.fq ${mode:sample}.rmUMI.R1.fq ${mode:sample}.rmUMI.R2.fq > ${mode:sample}.cutPrimer.log
depend = removeUMI

[syncFastqName]
# 由于read2不包含primer，cutadapt在处理完primer后，read1和read2名称不一致。因此自己写了一个脚本把read2的name和read1的name修改成一致
cmd = /data/users/dqgu/anaconda3/bin/python ~/PycharmProjects/nestcmd/SmallDrugPanel/sync_readname.py ${mode:sample}.rmUMI.rmPrimer1.R1.fq ${mode:sample}.rmUMI.rmPrimer1.R2.fq
depend = removePrimerInRead1

[removePrimerInRead2]
# 如果发生测通情况，read1和read2包含的信息一模一样，从read1中切除primer后，read2相对read1就自然多出一个primer的反向互补序列
# fastp会根据overlap自动识别出read2中的primer,并且将primer去除干净
# 理论上这个primer的去除不会影响比对，似乎可以省略，但或许对UMI collapse产生影响,
# 而且已经观察到primer可能连接的不是目标序列，去掉primer可以减少错误比对
# 由于fastp会先进行quality trim，然后进行adapter trim
# 而quality trim 可能导致read1末尾或read2的碱基被切除，这使得fastp根据overlap进行primer切除时出现偏差，因此使用-G，-Q参数禁止这个功能
cmd = /nfs2/software/fastp/fastp -Q -G -i ${mode:sample}.rmUMI.rmPrimer1.R1.fq -I ${mode:sample}.rmUMI.rmPrimer1.R2.fq -o ${mode:sample}.rmUMI.Primer12.R1.fq -O ${mode:sample}.rmUMI.Primer12.R2.fq -h ${mode:sample}.rmUMI.Primer12.html -j ${mode:sample}.rmUMI.Primer12.json
depend = syncFastqName

[finalQC]
# 最后再用fastp去除低质量reads，主要会过滤掉长度比较短的，包含N比较多的reads
# 为过滤掉复杂度极其低的read，加一个-Y参数=3%
cmd = /nfs2/software/fastp/fastp -Y 3 --disable_adapter_trimming --length_required 25 -i ${mode:sample}.rmUMI.Primer12.R1.fq -I ${mode:sample}.rmUMI.Primer12.R2.fq -h ${mode:sample}.final.html -j ${mode:sample}.final.json -o ${mode:sample}.final.R1.fq -O ${mode:sample}.final.R2.fq
depend = removePrimerInRead2

[umiRawStat]
# 对primer切除的日志文件进行解析，生成*.primer_stats.txt
cmd = /data/users/dqgu/anaconda3/bin/python /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/parse_cutadapt_info.py -file ${mode:sample}.cutPrimer.detail.txt -o ${mode:sample} -primer_fasta ${mode:primers}
depend = finalQC

[align]
cmd = ${mode:bwa} mem -M -Y -R "@RG\tID:${mode:sample}\tSM:${mode:sample}\tPL:Illumina" -t 5 ${mode:genome} ${mode:sample}.final.R1.fq ${mode:sample}.final.R2.fq -o ${mode:sample}.sam
depend = finalQC

[sortBam]
cmd = samtools sort ${mode:sample}.sam -o ${mode:sample}.sorted.bam
depend = align

[indexBam]
cmd = samtools index ${mode:sample}.sorted.bam
depend = sortBam

;[umiGroup]
;cmd = umi_tools group -I ${mode:sample}.sorted.bam --paired --buffer-whole-contig --group-out=groups.tsv --output-bam -S ${mode:sample}.umiGroup.bam --umi-separator=":"

[gencore]
cmd = /data/users/dqgu/anaconda3/bin/gencore --score_threshold 8 -i ${mode:sample}.sorted.bam -o ${mode:sample}.gencoreDedup.bam -r ${mode:genome} -u '' -b ${mode:roi}
depend = indexBam

[sortConsBam]
# 需要按照read name 排序才有利于fastq的正确转换
cmd = samtools sort -@4 ${mode:sample}.gencoreDedup.bam -o ${mode:sample}.gencoreDedup.sorted.bam
depend = gencore

[indexConsBam]
# 按照read name排序时无法建立索引
cmd = samtools index ${mode:sample}.gencoreDedup.sorted.bam
depend = sortConsBam

[umiStat]
# 统计gencore处理后的UMI信息，同时会输出on target的部分*.onTarget.bam
cmd = /data/users/dqgu/anaconda3/bin/python /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/primer_specific_stat.py -bam ${mode:sample}.gencoreDedup.sorted.bam -out_prefix ${mode:sample}.gencore --primer_trimmed
depend = indexConsBam

[sortOnTargetBam]
cmd = samtools sort ${mode:sample}.gencore.onTarget.bam -o ${mode:sample}.gencore.onTarget.sorted.bam
depend = umiStat

[indexOnTargetBam]
cmd = samtools index ${mode:sample}.gencore.onTarget.sorted.bam
depend = sortOnTargetBam

[sortConsBamByName]
cmd = samtools sort -@4 ${mode:sample}.gencoreDedup.bam -o ${mode:sample}.gencoreDedup.nameSorted.bam
depend = gencore

[bam2fastq]
cmd = samtools fastq --threads 3 -1 ${mode:sample}.gencore.R1.fq -2 ${mode:sample}.gencore.R2.fq ${mode:sample}.gencoreDedup.nameSorted.bam
depend = sortConsBamByName

;[mutscan]
;cmd = /data/users/dqgu/anaconda3/bin/mutscan -1 ${mode:sample}.gencore.R1.fq -2 ${mode:sample}.gencore.R2.fq -m ${mode:mutations} -r ${mode:genome} -j ${mode:sample}.mutscan.json -h ${mode:sample}.mutscan.html > ${mode:sample}.mutscan.result.txt
;depend = bam2fastq

[mutscan]
depend = finalQC
cmd = /data/users/dqgu/anaconda3/bin/mutscan -1 ${mode:sample}.final.R1.fq -2 ${mode:sample}.final.R2.fq -m ${mode:mutations} -r ${mode:genome} -j ${mode:sample}.mutscan.json -h ${mode:sample}.mutscan.html > ${mode:sample}.mutscan.result.txt

[vardict]
# 测试发现--header参数会导致转vcf时失败，不能够添加该参数
# -P 参数是根据突变是否在reads末尾出现进行过滤，由于read已经经过严格处理，将该参数调小到3
# 加--fisher参数，可以让vardict计算strand bias
cmd = /nfs2/software/vardictJava/VarDict-1.8.0/bin/VarDict -N ${mode:sample} -b ${mode:sample}.gencore.onTarget.sorted.bam -f 0.0001 -G ${mode:genome} -c 1 -S 2 -E 3 -g 4 -th 4 -q 20 -P 3 -UN --nosv --fisher ${mode:roi} | /nfs2/software/vardictJava/VarDict-1.8.0/bin/var2vcf_valid.pl -f 0.0001 > ${mode:sample}.vardict.vcf
depend = indexOnTargetBam

[seq_error_model]
# 构建错误率统计模型的背后：假设大部分低频突变都是PCR错误或者测序错误等导致的，并且前后的碱基影响这些错误的发生
cmd = /data/users/dqgu/anaconda3/bin/python /data/users/dqgu/PycharmProjects/nestcmd/VcfFilter/seq_error_model.py run -bed ${mode:roi} -bam ${mode:sample}.gencoreDedup.sorted.bam -prefix ${mode:sample}.seqError -genome ${mode:genome}
depend = sortConsBam

[vcfNorm]
# 进行左对齐标准化
cmd = bcftools norm -m -both -f ${mode:genome} -o ${mode:sample}.vardict.normed.vcf ${mode:sample}.vardict.vcf
depend = vardict

[filterVcf]
# 使用样本本身统计出来的错误率进行Vcf过滤, 目前暂无法证明该过滤方法是否完全可靠
cmd = /data/users/dqgu/anaconda3/bin/python /data/users/dqgu/PycharmProjects/nestcmd/VcfFilter/vardict_filter.py filterVcf -vcf ${mode:sample}.vardict.normed.vcf -seq_error ${mode:sample}.seqError.centered11_site.json -genome ${mode:genome}
depend = seq_error_model,vcfNorm

[annovar]
python = /data/users/dqgu/anaconda3/bin/python
cmd = ${python} /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/annovar.py -vcf ${mode:sample}.vardict.normed.filtered.vcf
depend = filterVcf

[consensusReads]
# 根据primer和UMI进行consensus，并且检测突变类型：snv,insertion, deletion, complex
# 所谓complex，只是把相邻的snv进行合并，暂不能将snv与相邻的insertion或deletion的合并
depend = indexBam
python = /data/users/dqgu/anaconda3/bin/python
script = /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/consensus_reads.py run_all
cmd = ${python} ${script} -primers ${mode:primers} -bam ${mode:sample}.sorted.bam -out_prefix ${mode:sample}

[Vcf2ROI]
depend = consensusReads
cmd = bedtools intersect -a ${mode:sample}.mutation.vcf -b ${mode:roi} -header > ${mode:sample}.ROI.mutation.vcf

[filterVcf2]
depend = Vcf2ROI,seq_error_model
python = /data/users/dqgu/anaconda3/bin/python
script = /data/users/dqgu/PycharmProjects/nestcmd/VcfFilter/vardict_filter.py filterVcf
cmd = ${python} ${script} -vcf ${mode:sample}.ROI.mutation.vcf -seq_error ${mode:sample}.seqError.centered11_site.json -genome ${mode:genome}

[vcfNorm2]
depend = filterVcf2
cmd = bcftools norm -m -both -f ${mode:genome} -o ${mode:sample}.ROI.mutation.filtered.normed.vcf ${mode:sample}.ROI.mutation.filtered.vcf

[annovar2]
depend = vcfNorm2
python = /data/users/dqgu/anaconda3/bin/python
cmd = ${python} /data/users/dqgu/PycharmProjects/nestcmd/SmallDrugPanel/annovar.py -vcf ${mode:sample}.ROI.mutation.filtered.normed.vcf

